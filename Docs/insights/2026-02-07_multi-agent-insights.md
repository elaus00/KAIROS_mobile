# 멀티 에이전트 개발 인사이트

> Phase 1 MVP 구현에서 4인 팀(data-model, ui-ux, feature, qa)을 운영하며 얻은 교훈.

## 효과적이었던 것

### 1. 레이어별 역할 분리가 병렬성을 극대화한다
- Data Layer(data-model)와 Domain Layer(feature)를 동시에 진행 가능했다.
  Domain 모델은 순수 Kotlin이라 Entity에 의존하지 않기 때문.
- UseCase 완료 전에도 UI 스크린 작업을 시작할 수 있었다.
  ViewModel이 UseCase를 주입받지만, 화면 레이아웃/UiState 구조는 독립적으로 설계 가능.

### 2. QA를 "전담 리뷰어 + 수정자"로 두면 품질이 올라간다
- QA가 리뷰만 하는 게 아니라 직접 수정 권한까지 가지니 병목이 줄었다.
- 리뷰 리포트를 문서로 남기면(review_phase1-1_1-2.md 등) 이슈 추적이 가능.
- QA가 레거시 삭제, Share Intent, Onboarding 등 "범위가 작지만 중요한" 태스크를 맡기에 적합.

### 3. Task 의존성 그래프가 자동 스케줄링 역할을 한다
- `blockedBy` 설정으로 Data→Domain→UseCase→UI 순서를 강제.
- 블로킹이 풀리면 자동으로 다음 태스크를 할당할 수 있어 리더 부담 감소.

## 문제점과 대응

### 1. 컨텍스트 소실 — 가장 큰 적
- 에이전트가 컨텍스트를 잃으면 이미 완료한 작업을 다시 하거나, 현재 상태를 파악 못함.
- **대응**: 태스크 상태를 TaskList로 관리하고, 메시지로 명시적으로 현재 상태를 전달.

### 2. 파일 충돌 — 같은 파일을 여러 에이전트가 수정
- NavGraph.kt, MainScreen.kt 등 공유 파일에서 충돌 발생 가능.
- **대응**: 공유 파일 수정은 한 에이전트에게만 할당하거나, 순차적으로 진행.

### 3. "idle 루프" — 에이전트가 할 일 없이 반복 응답
- 태스크가 없는 에이전트가 idle 알림을 계속 보냄. 노이즈 발생.
- **대응**: 할 일이 없는 에이전트는 즉시 다른 태스크를 할당하거나, 셧다운.

### 4. 코드 일관성 — 에이전트마다 코딩 스타일이 다름
- 한 에이전트는 `try-catch + fallback`, 다른 에이전트는 `valueOf()` 직접 호출.
- **대응**: QA 리뷰에서 패턴 통일. 초기에 코딩 컨벤션을 프롬프트에 더 구체적으로 명시할 것.

## 팀 구성 가이드라인

| 팀 규모 | 추천 구성 | 이유 |
|---------|----------|------|
| 2인 | 구현 + QA | 최소한의 리뷰 루프 |
| 4인 | data + domain + ui + qa | 레이어 분리와 병렬성 극대화 |
| 4인+ | 비추천 | 조율 비용이 병렬성 이득을 초과 |

## 핵심 원칙 (3줄 요약)

1. **태스크 의존성을 먼저 설계하라.** 병렬화 가능 범위가 곧 팀 효율.
2. **공유 파일 수정은 직렬화하라.** 충돌 해결 비용 > 순차 실행 비용.
3. **QA는 리뷰+수정 권한을 함께 줘라.** 리뷰만 하면 병목, 수정까지 하면 흐름이 끊기지 않는다.
