# 2026-02-07 Legacy Audit Lessons

## 배경
- 목표: 레거시/미사용 코드 대량 정리
- 결과: 화면 래퍼, 미사용 컴포넌트, 미사용 UseCase, 미사용 UI 유틸 삭제 완료
- 추가 검증: 사용자 제보 리스트 기반으로 항목별 사실관계 재검증

## 이번 작업에서 얻은 교훈

1. "참조 0회"와 "실사용 0회"는 다르다.
- 인터페이스/구현/테스트 참조만으로는 실제 실행 경로를 보장하지 못한다.
- 반드시 `정의/override/실호출(프로덕션)`을 분리해서 판단해야 한다.

2. 1차 스캔은 후보 추출, 2차 스캔은 판정이다.
- 키워드/이름 기반 검색은 빠르지만 오탐·누락이 생긴다.
- 최종 판정은 화면 이벤트 → ViewModel → UseCase/Repository → DAO/API까지 호출 그래프를 닫아야 한다.

3. "테스트에서만 사용" 항목은 삭제 후보로 분류해야 한다.
- 테스트 참조가 존재해도 프로덕션 경로 미연결이면 레거시 가능성이 높다.
- 보고 시 `Prod only`와 `Test only`를 분리해야 의사결정이 빨라진다.

4. UI 상태값은 "표시 여부"와 "필터 반영 여부"를 분리 확인해야 한다.
- 필드가 화면에 직접 노출되지 않아도 쿼리 파라미터로 사용될 수 있다.
- 반대로 ViewModel에 값이 있어도 UI에서 이벤트를 발생시키지 않으면 사실상 미사용이다.

5. 어댑터/호환 계층은 제거보다 근거 확보가 우선이다.
- `CalendarNotifier`처럼 구현체가 교체 포인트를 제공하면 유지 가치가 있다.
- "호환성용으로만 보이는 코드"는 바인딩 및 런타임 호출 증거를 먼저 확인한다.

6. 대규모 정리는 "컴파일 성공"을 최소 게이트로 둔다.
- 삭제 후 `compileDebugKotlin` 같은 빠른 게이트를 즉시 통과시켜야 회귀를 줄일 수 있다.
- lint/test는 별도 트랙으로 두되, 삭제 작업의 안전성 확인은 컴파일 게이트를 우선한다.

## 재발 방지 체크리스트

- [ ] 항목별로 `정의/구현/실호출` 3단계 증거를 남겼는가
- [ ] `프로덕션 호출`과 `테스트 호출`을 분리 표기했는가
- [ ] UI 이벤트가 실제로 ViewModel 함수를 트리거하는지 확인했는가
- [ ] 인터페이스 메서드는 구현 내부 참조가 아니라 외부 호출 기준으로 판단했는가
- [ ] 삭제 후 최소 컴파일 게이트를 통과했는가

## 실행 기준 (다음 정리 작업부터 적용)

- 확정 삭제: 프로덕션 호출 0, 테스트 호출 0
- 조건부 삭제: 프로덕션 호출 0, 테스트 호출 >0 (테스트 정리와 함께 삭제)
- 보류: 프로덕션 호출 >0 또는 런타임 경로 증거 존재

